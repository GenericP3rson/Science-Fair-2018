Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var convnet_vol_1 = require("./convnet_vol");
var layers_1 = require("./layers");
var util = require("./convnet_util");
var DotproductsLayer = (function (_super) {
    tslib_1.__extends(DotproductsLayer, _super);
    function DotproductsLayer(opt) {
        var _this = this;
        if (!opt) {
            return;
        }
        _this = _super.call(this) || this;
        // optional
        _this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;
        _this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;
        return _this;
    }
    return DotproductsLayer;
}(layers_1.LayerBase));
exports.DotproductsLayer = DotproductsLayer;
/**
 * ConvLayer does convolutions (so weight sharing spatially)
*/
var ConvLayer = (function (_super) {
    tslib_1.__extends(ConvLayer, _super);
    function ConvLayer(opt) {
        var _this = this;
        if (!opt) {
            return;
        }
        var copt = opt;
        _this = _super.call(this, copt) || this;
        // required
        _this.out_depth = copt.filters;
        _this.sx = copt.sx; // filter size. Should be odd if possible, it's cleaner.
        _this.in_depth = copt.in_depth;
        _this.in_sx = copt.in_sx;
        _this.in_sy = copt.in_sy;
        // optional
        _this.sy = typeof copt.sy !== 'undefined' ? copt.sy : _this.sx;
        _this.stride = typeof copt.stride !== 'undefined' ? copt.stride : 1; // stride at which we apply filters to input volume
        _this.pad = typeof copt.pad !== 'undefined' ? copt.pad : 0; // amount of 0 padding to add around borders of input volume
        // computed
        // note we are doing floor, so if the strided convolution of the filter doesnt fit into the input
        // volume exactly, the output volume will be trimmed and not contain the (incomplete) computed
        // final application.
        _this.out_sx = Math.floor((_this.in_sx + _this.pad * 2 - _this.sx) / _this.stride + 1);
        _this.out_sy = Math.floor((_this.in_sy + _this.pad * 2 - _this.sy) / _this.stride + 1);
        _this.layer_type = 'conv';
        // initializations
        _this.filters = [];
        for (var i = 0; i < _this.out_depth; i++) {
            _this.filters.push(new convnet_vol_1.Vol(_this.sx, _this.sy, _this.in_depth));
        }
        var bias = (typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0);
        _this.biases = new convnet_vol_1.Vol(1, 1, _this.out_depth, bias);
        return _this;
    }
    ConvLayer.prototype.forward = function (V) {
        // optimized code by @mdda that achieves 2x speedup over previous version
        this.in_act = V;
        var A = new convnet_vol_1.Vol(this.out_sx | 0, this.out_sy | 0, this.out_depth | 0, 0.0);
        var V_sx = V.sx | 0;
        var V_sy = V.sy | 0;
        var xy_stride = this.stride | 0;
        for (var d = 0; d < this.out_depth; d++) {
            var f = this.filters[d];
            var x = -this.pad | 0;
            var y = -this.pad | 0;
            for (var ay = 0; ay < this.out_sy; y += xy_stride, ay++) {
                x = -this.pad | 0;
                for (var ax = 0; ax < this.out_sx; x += xy_stride, ax++) {
                    // convolve centered at this particular location
                    var a = 0.0;
                    for (var fy = 0; fy < f.sy; fy++) {
                        var oy = y + fy; // coordinates in the original input array coordinates
                        for (var fx = 0; fx < f.sx; fx++) {
                            var ox = x + fx;
                            if (oy >= 0 && oy < V_sy && ox >= 0 && ox < V_sx) {
                                for (var fd = 0; fd < f.depth; fd++) {
                                    // avoid function call overhead (x2) for efficiency, compromise modularity :(
                                    a += f.w[((f.sx * fy) + fx) * f.depth + fd] * V.w[((V_sx * oy) + ox) * V.depth + fd];
                                }
                            }
                        }
                    }
                    a += this.biases.w[d];
                    A.set(ax, ay, d, a);
                }
            }
        }
        this.out_act = A;
        return this.out_act;
    };
    ConvLayer.prototype.backward = function () {
        var V = this.in_act;
        V.dw = util.zeros(V.w.length); // zero out gradient wrt bottom data, we're about to fill it
        var V_sx = V.sx | 0;
        var V_sy = V.sy | 0;
        var xy_stride = this.stride | 0;
        for (var d = 0; d < this.out_depth; d++) {
            var f = this.filters[d];
            var x = -this.pad | 0;
            var y = -this.pad | 0;
            for (var ay = 0; ay < this.out_sy; y += xy_stride, ay++) {
                x = -this.pad | 0;
                for (var ax = 0; ax < this.out_sx; x += xy_stride, ax++) {
                    // convolve centered at this particular location
                    var chain_grad = this.out_act.get_grad(ax, ay, d); // gradient from above, from chain rule
                    for (var fy = 0; fy < f.sy; fy++) {
                        var oy = y + fy; // coordinates in the original input array coordinates
                        for (var fx = 0; fx < f.sx; fx++) {
                            var ox = x + fx;
                            if (oy >= 0 && oy < V_sy && ox >= 0 && ox < V_sx) {
                                for (var fd = 0; fd < f.depth; fd++) {
                                    // avoid function call overhead (x2) for efficiency, compromise modularity :(
                                    var ix1 = ((V_sx * oy) + ox) * V.depth + fd;
                                    var ix2 = ((f.sx * fy) + fx) * f.depth + fd;
                                    f.dw[ix2] += V.w[ix1] * chain_grad;
                                    V.dw[ix1] += f.w[ix2] * chain_grad;
                                }
                            }
                        }
                    }
                    this.biases.dw[d] += chain_grad;
                }
            }
        }
        return 0;
    };
    ConvLayer.prototype.getParamsAndGrads = function () {
        var response = [];
        for (var i = 0; i < this.out_depth; i++) {
            response.push({ params: this.filters[i].w, grads: this.filters[i].dw, l2_decay_mul: this.l2_decay_mul, l1_decay_mul: this.l1_decay_mul });
        }
        response.push({ params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0.0, l2_decay_mul: 0.0 });
        return response;
    };
    ConvLayer.prototype.toJSON = function () {
        var json = {};
        json.sx = this.sx; // filter size in x, y dims
        json.sy = this.sy;
        json.stride = this.stride;
        json.in_depth = this.in_depth;
        json.out_depth = this.out_depth;
        json.out_sx = this.out_sx;
        json.out_sy = this.out_sy;
        json.layer_type = this.layer_type;
        json.l1_decay_mul = this.l1_decay_mul;
        json.l2_decay_mul = this.l2_decay_mul;
        json.pad = this.pad;
        json.filters = [];
        for (var i = 0; i < this.filters.length; i++) {
            json.filters.push(this.filters[i].toJSON());
        }
        json.biases = this.biases.toJSON();
        return json;
    };
    ConvLayer.prototype.fromJSON = function (json) {
        this.out_depth = json.out_depth;
        this.out_sx = json.out_sx;
        this.out_sy = json.out_sy;
        this.layer_type = json.layer_type;
        this.sx = json.sx; // filter size in x, y dims
        this.sy = json.sy;
        this.stride = json.stride;
        this.in_depth = json.in_depth; // depth of input volume
        this.filters = [];
        this.l1_decay_mul = (typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0);
        this.l2_decay_mul = (typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0);
        this.pad = (typeof json.pad !== 'undefined' ? json.pad : 0);
        for (var i = 0; i < json.filters.length; i++) {
            var v = new convnet_vol_1.Vol(0, 0, 0, 0);
            v.fromJSON(json.filters[i]);
            this.filters.push(v);
        }
        this.biases = new convnet_vol_1.Vol(0, 0, 0, 0);
        this.biases.fromJSON(json.biases);
    };
    return ConvLayer;
}(DotproductsLayer));
exports.ConvLayer = ConvLayer;
/**
 * FullyConn is fully connected dot products
 */
var FullyConnLayer = (function (_super) {
    tslib_1.__extends(FullyConnLayer, _super);
    function FullyConnLayer(opt) {
        var _this = this;
        if (!opt) {
            return;
        }
        var fcopt = opt;
        _this = _super.call(this, fcopt) || this;
        // required
        // ok fine we will allow 'filters' as the word as well
        _this.out_depth = typeof fcopt.num_neurons !== 'undefined' ? fcopt.num_neurons : fcopt.filters;
        // computed
        _this.num_inputs = fcopt.in_sx * fcopt.in_sy * fcopt.in_depth;
        _this.out_sx = 1;
        _this.out_sy = 1;
        _this.layer_type = 'fc';
        // initializations
        _this.filters = [];
        for (var i = 0; i < _this.out_depth; i++) {
            _this.filters.push(new convnet_vol_1.Vol(1, 1, _this.num_inputs));
        }
        var bias = (typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0);
        _this.biases = new convnet_vol_1.Vol(1, 1, _this.out_depth, bias);
        return _this;
    }
    FullyConnLayer.prototype.forward = function (V) {
        this.in_act = V;
        var A = new convnet_vol_1.Vol(1, 1, this.out_depth, 0.0);
        var Vw = V.w;
        for (var i = 0; i < this.out_depth; i++) {
            var a = 0.0;
            var wi = this.filters[i].w;
            for (var d = 0; d < this.num_inputs; d++) {
                a += Vw[d] * wi[d]; // for efficiency use Vols directly for now
            }
            a += this.biases.w[i];
            A.w[i] = a;
        }
        this.out_act = A;
        return this.out_act;
    };
    FullyConnLayer.prototype.backward = function () {
        var V = this.in_act;
        V.dw = util.zeros(V.w.length); // zero out the gradient in input Vol
        // compute gradient wrt weights and data
        for (var i = 0; i < this.out_depth; i++) {
            var tfi = this.filters[i];
            var chain_grad = this.out_act.dw[i];
            for (var d = 0; d < this.num_inputs; d++) {
                V.dw[d] += tfi.w[d] * chain_grad; // grad wrt input data
                tfi.dw[d] += V.w[d] * chain_grad; // grad wrt params
            }
            this.biases.dw[i] += chain_grad;
        }
    };
    FullyConnLayer.prototype.getParamsAndGrads = function () {
        var response = [];
        for (var i = 0; i < this.out_depth; i++) {
            response.push({ params: this.filters[i].w, grads: this.filters[i].dw, l1_decay_mul: this.l1_decay_mul, l2_decay_mul: this.l2_decay_mul });
        }
        response.push({ params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0.0, l2_decay_mul: 0.0 });
        return response;
    };
    FullyConnLayer.prototype.toJSON = function () {
        var json = {};
        json.out_depth = this.out_depth;
        json.out_sx = this.out_sx;
        json.out_sy = this.out_sy;
        json.layer_type = this.layer_type;
        json.num_inputs = this.num_inputs;
        json.l1_decay_mul = this.l1_decay_mul;
        json.l2_decay_mul = this.l2_decay_mul;
        json.filters = [];
        for (var i = 0; i < this.filters.length; i++) {
            json.filters.push(this.filters[i].toJSON());
        }
        json.biases = this.biases.toJSON();
        return json;
    };
    FullyConnLayer.prototype.fromJSON = function (json) {
        this.out_depth = json.out_depth;
        this.out_sx = json.out_sx;
        this.out_sy = json.out_sy;
        this.layer_type = json.layer_type;
        this.num_inputs = json.num_inputs;
        this.l1_decay_mul = (typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0);
        this.l2_decay_mul = (typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0);
        this.filters = [];
        for (var i = 0; i < json.filters.length; i++) {
            var v = new convnet_vol_1.Vol(0, 0, 0, 0);
            v.fromJSON(json.filters[i]);
            this.filters.push(v);
        }
        this.biases = new convnet_vol_1.Vol(0, 0, 0, 0);
        this.biases.fromJSON(json.biases);
    };
    return FullyConnLayer;
}(DotproductsLayer));
exports.FullyConnLayer = FullyConnLayer;
//# sourceMappingURL=convnet_layers_dotproducts.js.map