Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var convnet_vol_1 = require("./convnet_vol");
var layers_1 = require("./layers");
var util = require("./convnet_util");
var OutputLayer = (function (_super) {
    tslib_1.__extends(OutputLayer, _super);
    function OutputLayer(opt) {
        var _this = _super.call(this, opt) || this;
        _this.out_sx = opt.in_sx;
        _this.out_sy = opt.in_sy;
        _this.out_depth = opt.in_depth;
        return _this;
    }
    return OutputLayer;
}(layers_1.LayerBase));
exports.OutputLayer = OutputLayer;
/**
 * Implements ReLU nonlinearity elementwise
 * x -> max(0, x)
 * the output is in [0, inf)
 */
var ReluLayer = (function (_super) {
    tslib_1.__extends(ReluLayer, _super);
    function ReluLayer(opt) {
        var _this = this;
        if (!opt) {
            return;
        }
        _this = _super.call(this, opt) || this;
        // computed
        _this.layer_type = 'relu';
        return _this;
    }
    ReluLayer.prototype.forward = function (V) {
        this.in_act = V;
        var V2 = V.clone();
        var N = V.w.length;
        var V2w = V2.w;
        for (var i = 0; i < N; i++) {
            if (V2w[i] < 0) {
                V2w[i] = 0; // threshold at 0
            }
            this.out_act = V2;
            return this.out_act;
        }
    };
    ReluLayer.prototype.backward = function () {
        var V = this.in_act; // we need to set dw of this
        var V2 = this.out_act;
        var N = V.w.length;
        V.dw = util.zeros(N); // zero out gradient wrt data
        for (var i = 0; i < N; i++) {
            if (V2.w[i] <= 0) {
                V.dw[i] = 0; // threshold
            }
            else {
                V.dw[i] = V2.dw[i];
            }
        }
    };
    ReluLayer.prototype.getParamsAndGrads = function () {
        return [];
    };
    ReluLayer.prototype.toJSON = function () {
        var json = {};
        json.out_depth = this.out_depth;
        json.out_sx = this.out_sx;
        json.out_sy = this.out_sy;
        json.layer_type = this.layer_type;
        return json;
    };
    ReluLayer.prototype.fromJSON = function (json) {
        this.out_depth = json.out_depth;
        this.out_sx = json.out_sx;
        this.out_sy = json.out_sy;
        this.layer_type = json.layer_type;
    };
    return ReluLayer;
}(OutputLayer));
exports.ReluLayer = ReluLayer;
/**
 * Implements Sigmoid nnonlinearity elementwise
 * x -> 1/(1+e^(-x))
 * so the output is between 0 and 1.
 */
var SigmoidLayer = (function (_super) {
    tslib_1.__extends(SigmoidLayer, _super);
    function SigmoidLayer(opt) {
        var _this = this;
        if (!opt) {
            return;
        }
        _this = _super.call(this, opt) || this;
        // computed
        _this.layer_type = 'sigmoid';
        return _this;
    }
    SigmoidLayer.prototype.forward = function (V) {
        this.in_act = V;
        var V2 = V.cloneAndZero();
        var N = V.w.length;
        var V2w = V2.w;
        var Vw = V.w;
        for (var i = 0; i < N; i++) {
            V2w[i] = 1.0 / (1.0 + Math.exp(-Vw[i]));
        }
        this.out_act = V2;
        return this.out_act;
    };
    SigmoidLayer.prototype.backward = function () {
        var V = this.in_act; // we need to set dw of this
        var V2 = this.out_act;
        var N = V.w.length;
        V.dw = util.zeros(N); // zero out gradient wrt data
        for (var i = 0; i < N; i++) {
            var v2wi = V2.w[i];
            V.dw[i] = v2wi * (1.0 - v2wi) * V2.dw[i];
        }
    };
    SigmoidLayer.prototype.getParamsAndGrads = function () {
        return [];
    };
    SigmoidLayer.prototype.toJSON = function () {
        var json = {};
        json.out_depth = this.out_depth;
        json.out_sx = this.out_sx;
        json.out_sy = this.out_sy;
        json.layer_type = this.layer_type;
        return json;
    };
    SigmoidLayer.prototype.fromJSON = function (json) {
        this.out_depth = json.out_depth;
        this.out_sx = json.out_sx;
        this.out_sy = json.out_sy;
        this.layer_type = json.layer_type;
    };
    return SigmoidLayer;
}(OutputLayer));
exports.SigmoidLayer = SigmoidLayer;
// Implements Maxout nnonlinearity that computes
// x -> max(x)
// where x is a vector of size group_size. Ideally of course,
// the input size should be exactly divisible by group_size
var MaxoutLayer = (function (_super) {
    tslib_1.__extends(MaxoutLayer, _super);
    function MaxoutLayer(opt) {
        var _this = this;
        if (!opt) {
            return;
        }
        var mopt = opt;
        _this = _super.call(this, mopt) || this;
        // required
        _this.group_size = typeof mopt.group_size !== 'undefined' ? mopt.group_size : 2;
        // computed
        _this.out_depth = Math.floor(mopt.in_depth / _this.group_size);
        _this.layer_type = 'maxout';
        _this.switches = util.zeros(_this.out_sx * _this.out_sy * _this.out_depth); // useful for backprop
        return _this;
    }
    MaxoutLayer.prototype.forward = function (V) {
        this.in_act = V;
        var N = this.out_depth;
        var V2 = new convnet_vol_1.Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);
        // optimization branch. If we're operating on 1D arrays we dont have
        // to worry about keeping track of x,y,d coordinates inside
        // input volumes. In convnets we do :(
        if (this.out_sx === 1 && this.out_sy === 1) {
            for (var i = 0; i < N; i++) {
                var ix = i * this.group_size; // base index offset
                var a = V.w[ix];
                var ai = 0;
                for (var j = 1; j < this.group_size; j++) {
                    var a2 = V.w[ix + j];
                    if (a2 > a) {
                        a = a2;
                        ai = j;
                    }
                }
                V2.w[i] = a;
                this.switches[i] = ix + ai;
            }
        }
        else {
            var n = 0; // counter for switches
            for (var x = 0; x < V.sx; x++) {
                for (var y = 0; y < V.sy; y++) {
                    for (var i = 0; i < N; i++) {
                        var ix = i * this.group_size;
                        var a = V.get(x, y, ix);
                        var ai = 0;
                        for (var j = 1; j < this.group_size; j++) {
                            var a2 = V.get(x, y, ix + j);
                            if (a2 > a) {
                                a = a2;
                                ai = j;
                            }
                        }
                        V2.set(x, y, i, a);
                        this.switches[n] = ix + ai;
                        n++;
                    }
                }
            }
        }
        this.out_act = V2;
        return this.out_act;
    };
    MaxoutLayer.prototype.backward = function () {
        var V = this.in_act; // we need to set dw of this
        var V2 = this.out_act;
        var N = this.out_depth;
        V.dw = util.zeros(V.w.length); // zero out gradient wrt data
        // pass the gradient through the appropriate switch
        if (this.out_sx === 1 && this.out_sy === 1) {
            for (var i = 0; i < N; i++) {
                var chain_grad = V2.dw[i];
                V.dw[this.switches[i]] = chain_grad;
            }
        }
        else {
            // bleh okay, lets do this the hard way
            var n = 0; // counter for switches
            for (var x = 0; x < V2.sx; x++) {
                for (var y = 0; y < V2.sy; y++) {
                    for (var i = 0; i < N; i++) {
                        var chain_grad = V2.get_grad(x, y, i);
                        V.set_grad(x, y, this.switches[n], chain_grad);
                        n++;
                    }
                }
            }
        }
    };
    MaxoutLayer.prototype.getParamsAndGrads = function () {
        return [];
    };
    MaxoutLayer.prototype.toJSON = function () {
        var json = {};
        json.out_depth = this.out_depth;
        json.out_sx = this.out_sx;
        json.out_sy = this.out_sy;
        json.layer_type = this.layer_type;
        json.group_size = this.group_size;
        return json;
    };
    MaxoutLayer.prototype.fromJSON = function (json) {
        this.out_depth = json.out_depth;
        this.out_sx = json.out_sx;
        this.out_sy = json.out_sy;
        this.layer_type = json.layer_type;
        this.group_size = json.group_size;
        this.switches = util.zeros(this.group_size);
    };
    return MaxoutLayer;
}(OutputLayer));
exports.MaxoutLayer = MaxoutLayer;
/**
 * a helper function, since tanh is not yet part of ECMAScript. Will be in v6.
 */
function tanh(x) {
    var y = Math.exp(2 * x);
    return (y - 1) / (y + 1);
}
// Implements Tanh nnonlinearity elementwise
// x -> tanh(x)
// so the output is between -1 and 1.
var TanhLayer = (function (_super) {
    tslib_1.__extends(TanhLayer, _super);
    function TanhLayer(opt) {
        var _this = this;
        if (!opt) {
            return;
        }
        _this = _super.call(this, opt) || this;
        // computed
        _this.layer_type = 'tanh';
        return _this;
    }
    TanhLayer.prototype.forward = function (V) {
        this.in_act = V;
        var V2 = V.cloneAndZero();
        var N = V.w.length;
        for (var i = 0; i < N; i++) {
            V2.w[i] = tanh(V.w[i]);
        }
        this.out_act = V2;
        return this.out_act;
    };
    TanhLayer.prototype.backward = function () {
        var V = this.in_act; // we need to set dw of this
        var V2 = this.out_act;
        var N = V.w.length;
        V.dw = util.zeros(N); // zero out gradient wrt data
        for (var i = 0; i < N; i++) {
            var v2wi = V2.w[i];
            V.dw[i] = (1.0 - v2wi * v2wi) * V2.dw[i];
        }
    };
    TanhLayer.prototype.getParamsAndGrads = function () {
        return [];
    };
    TanhLayer.prototype.toJSON = function () {
        var json = {};
        json.out_depth = this.out_depth;
        json.out_sx = this.out_sx;
        json.out_sy = this.out_sy;
        json.layer_type = this.layer_type;
        return json;
    };
    TanhLayer.prototype.fromJSON = function (json) {
        this.out_depth = json.out_depth;
        this.out_sx = json.out_sx;
        this.out_sy = json.out_sy;
        this.layer_type = json.layer_type;
    };
    return TanhLayer;
}(OutputLayer));
exports.TanhLayer = TanhLayer;
//# sourceMappingURL=convnet_layers_nonlinearities.js.map