import { Vol } from "./convnet_vol";
import { LayerBase, LayerOptions, ILayer, LayerJSON, ParamsAndGrads } from "./layers";
export interface LossLayerOptions extends LayerOptions {
    /** <required> */
    num_classes: number;
}
/** This is a classifier, with N discrete classes from 0 to N-1
 * it gets a stream of N incoming numbers and computes the softmax
 * function (exponentiate and normalize to sum to 1 as probabilities should)
 */
export declare class SoftmaxLayer extends LayerBase implements ILayer {
    in_act: Vol;
    num_inputs: number;
    out_act: Vol;
    es: number[] | Float64Array;
    constructor(opt?: LayerOptions);
    forward(V: Vol): Vol;
    backward(y: number): number;
    getParamsAndGrads(): ParamsAndGrads[];
    toJSON(): LayerJSON;
    fromJSON(json: LayerJSON): void;
}
/**
 * implements an L2 regression cost layer,
 * so penalizes \sum_i(||x_i - y_i||^2), where x is its input
 * and y is the user-provided array of "correct" values.
 */
export declare class RegressionLayer extends LayerBase implements ILayer {
    num_inputs: number;
    in_act: Vol;
    out_act: Vol;
    constructor(opt?: LayerOptions);
    forward(V: Vol): Vol;
    backward(y: number | number[] | Float64Array | {
        [key: string]: number;
    }): number;
    getParamsAndGrads(): ParamsAndGrads[];
    toJSON(): LayerJSON;
    fromJSON(json: LayerJSON): void;
}
export declare class SVMLayer extends LayerBase implements ILayer {
    num_inputs: number;
    in_act: Vol;
    out_act: Vol;
    constructor(opt?: LayerOptions);
    forward(V: Vol): Vol;
    backward(y: number): number;
    getParamsAndGrads(): ParamsAndGrads[];
    toJSON(): LayerJSON;
    fromJSON(json: LayerJSON): void;
}
