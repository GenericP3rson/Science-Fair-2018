Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var convnet_vol_1 = require("./convnet_vol");
var layers_1 = require("./layers");
var util = require("./convnet_util");
var PoolLayer = (function (_super) {
    tslib_1.__extends(PoolLayer, _super);
    function PoolLayer(opt) {
        var _this = this;
        if (!opt) {
            return;
        }
        var popt = opt;
        _this = _super.call(this, popt) || this;
        // required
        _this.sx = popt.sx; // filter size
        _this.in_depth = popt.in_depth;
        _this.in_sx = popt.in_sx;
        _this.in_sy = popt.in_sy;
        // optional
        _this.sy = typeof popt.sy !== 'undefined' ? popt.sy : _this.sx;
        _this.stride = typeof popt.stride !== 'undefined' ? popt.stride : 2;
        _this.pad = typeof popt.pad !== 'undefined' ? popt.pad : 0; // amount of 0 padding to add around borders of input volume
        // computed
        _this.out_depth = _this.in_depth;
        _this.out_sx = Math.floor((_this.in_sx + _this.pad * 2 - _this.sx) / _this.stride + 1);
        _this.out_sy = Math.floor((_this.in_sy + _this.pad * 2 - _this.sy) / _this.stride + 1);
        _this.layer_type = 'pool';
        // store switches for x,y coordinates for where the max comes from, for each output neuron
        _this.switchx = util.zeros(_this.out_sx * _this.out_sy * _this.out_depth);
        _this.switchy = util.zeros(_this.out_sx * _this.out_sy * _this.out_depth);
        return _this;
    }
    PoolLayer.prototype.forward = function (V) {
        this.in_act = V;
        var A = new convnet_vol_1.Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);
        var n = 0; // a counter for switches
        for (var d = 0; d < this.out_depth; d++) {
            var x = -this.pad;
            var y = -this.pad;
            for (var ax = 0; ax < this.out_sx; x += this.stride, ax++) {
                y = -this.pad;
                for (var ay = 0; ay < this.out_sy; y += this.stride, ay++) {
                    // convolve centered at this particular location
                    var a = -99999; // hopefully small enough ;\
                    var winx = -1, winy = -1;
                    for (var fx = 0; fx < this.sx; fx++) {
                        for (var fy = 0; fy < this.sy; fy++) {
                            var oy = y + fy;
                            var ox = x + fx;
                            if (oy >= 0 && oy < V.sy && ox >= 0 && ox < V.sx) {
                                var v = V.get(ox, oy, d);
                                // perform max pooling and store pointers to where
                                // the max came from. This will speed up backprop
                                // and can help make nice visualizations in future
                                if (v > a) {
                                    a = v;
                                    winx = ox;
                                    winy = oy;
                                }
                            }
                        }
                    }
                    this.switchx[n] = winx;
                    this.switchy[n] = winy;
                    n++;
                    A.set(ax, ay, d, a);
                }
            }
        }
        this.out_act = A;
        return this.out_act;
    };
    PoolLayer.prototype.backward = function () {
        // pooling layers have no parameters, so simply compute
        // gradient wrt data here
        var V = this.in_act;
        V.dw = util.zeros(V.w.length); // zero out gradient wrt data
        // const A = this.out_act; // computed in forward pass
        var n = 0;
        for (var d = 0; d < this.out_depth; d++) {
            var x = -this.pad;
            var y = -this.pad;
            for (var ax = 0; ax < this.out_sx; x += this.stride, ax++) {
                y = -this.pad;
                for (var ay = 0; ay < this.out_sy; y += this.stride, ay++) {
                    var chain_grad = this.out_act.get_grad(ax, ay, d);
                    V.add_grad(this.switchx[n], this.switchy[n], d, chain_grad);
                    n++;
                }
            }
        }
    };
    PoolLayer.prototype.getParamsAndGrads = function () {
        return [];
    };
    PoolLayer.prototype.toJSON = function () {
        var json = {};
        json.sx = this.sx;
        json.sy = this.sy;
        json.stride = this.stride;
        json.in_depth = this.in_depth;
        json.out_depth = this.out_depth;
        json.out_sx = this.out_sx;
        json.out_sy = this.out_sy;
        json.layer_type = this.layer_type;
        json.pad = this.pad;
        return json;
    };
    PoolLayer.prototype.fromJSON = function (json) {
        this.out_depth = json.out_depth;
        this.out_sx = json.out_sx;
        this.out_sy = json.out_sy;
        this.layer_type = json.layer_type;
        this.sx = json.sx;
        this.sy = json.sy;
        this.stride = json.stride;
        this.in_depth = json.in_depth;
        this.pad = (typeof json.pad !== 'undefined' ? json.pad : 0); // backwards compatibility
        this.switchx = util.zeros(this.out_sx * this.out_sy * this.out_depth); // need to re-init these appropriately
        this.switchy = util.zeros(this.out_sx * this.out_sy * this.out_depth);
    };
    return PoolLayer;
}(layers_1.LayerBase));
exports.PoolLayer = PoolLayer;
//# sourceMappingURL=convnet_layers_pool.js.map